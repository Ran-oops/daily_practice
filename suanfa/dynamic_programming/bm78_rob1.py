"""BM78 打家劫舍(一)
描述
你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，
就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。
给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。

数据范围：数组长度满足 1≤n≤2×10^5，数组中每个值满足 1≤num[i]≤5000

"""

"""
动态规划思路
1.状态定义：
    dp[i]表示偷到第i个房间时（包含第i个房间）能获得的最大金额
2.状态转移方程：
    对于第i个房间，有两种选择：
        不偷第i个房间：最大金额 = dp[i-1]
        偷第i个房间：最大金额 = dp[i-2] + nums[i]
    因此：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
3.边界条件：
    dp[0] = nums[0]（只有1间房）
    dp[1] = max(nums[0], nums[1])（2间房时取较大值）
"""


def rob(nums):
    if not nums:
        return 0
    if len(nums) <= 2:
        return max(nums)

    # 初始化DP数组，dp[i]表示偷到第i个房间时的最大金额
    dp = [0] * len(nums)

    # 初始状态
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    # 状态转移
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

    return dp[-1]




